---
title: "R Notebook"
output: html_notebook
---


```{r}
### ENTER ROOT DIR PATH BELOW, or keep the renv/project rootdir
rootdir <- getwd()
Robjectsdir <- paste0(rootdir, "/Robjects")
Graphsdir <- paste0(rootdir, "/graphs")
BVdir <- paste0(Graphsdir, "/BioVar")
# make heatmaps graph folder
if (!dir.exists(file.path(Graphsdir, "Heatmaps"))) {
  dir.create(file.path(Graphsdir, "Heatmaps"))
}
Heatdir <- paste0(Graphsdir, "/Heatmaps")
# make volcano plots graph folder
if (!dir.exists(file.path(Graphsdir, "Volcanoes"))) {
  dir.create(file.path(Graphsdir, "Volcanoes"))
}
Volcanodir <- paste0(Graphsdir, "/Volcanoes")


### ENTER PATH WITH KALLISTO FOLDERS BELOW
datapath <- paste0(rootdir, "/input")

# sample names for all samples
sample_list <- dir(file.path(datapath))
# paths to each kallisto folder for each processed sample
kal_dirs <- file.path(datapath, sample_list)

#setting root directory
knitr::opts_knit$set(root.dir = rootdir)
# options(max.print = .Machine$integer.max, scipen = 999, stringsAsFactors = F, dplyr.summarise.inform = F) # avoid truncated output in R console and scientific notation
# Set seed to ensure reproducibility in any function sthat require randomness
set.seed(123456)
suppressMessages({
  library(edgeR)    # for DGE analysis
  library(pheatmap) # for heatmap graphs
  library(dplyr)    # for useful modification functions of dataframes, lists, etc
  library(data.table)      # to reorder the t2ged matrix
  library(clusterProfiler) # ORA/GSEA
  library(org.Dm.eg.db)    # Dmel db for GO terms/Kegg pathways
  library(DOSE)            # for some graphing functions (facet_grid)
  library(enrichplot)      # Graphing functions (pairwise_termsim)
  library(ggplot2)  # graphing module
  library(pathview) # to produce pathview plots of KEGG pathways with enriched genes/transcripts 
  library(cowplot)
  #library(tidyverse) # includes ggplot2, for data visualisation. dplyr, for data manipulation.
  library(RColorBrewer) # for a colourful plot
  library(ggrepel) # for nice annotations
  library(cluster)         # for PAM clustering function
  library(factoextra)      # for the various graphing methods in finding optimal k number
  library(openxlsx) # to save enrichment analysis results
  library(forcats) # to reverse order of factor for avglogCPM function
  library(tximport)
})
```

```{r loading relevant values}
if (!exists("y")){
  y <- readRDS(file = paste0(Robjectsdir, "/y_gene.rds"))
}
if (!exists("fit")){
  fit <- readRDS(file = paste0(Robjectsdir, "/fit.rds"))
}
if (!exists("s2c")){
  s2c <- readRDS(file = paste0(Robjectsdir, "/s2c.rds"))
  design <- s2c$design
}
if (!exists("t2g")){
  t2g <- readRDS(file = paste0(Robjectsdir, "/t2g_dmel.rds"))
}
if (!exists("logCPM")){
  logCPM <- readRDS(file = paste0(Robjectsdir, "/logCPM.rds"))
  avlogCPM <- readRDS(file = paste0(Robjectsdir, "/avlogCPM.rds"))
}
if (!exists("glmQL_res")){
  glmQL_res <- readRDS(file = paste0(Robjectsdir, "/glmQL_res_txi.rds"))
  glmQL_decided <- readRDS(file = paste0(Robjectsdir, "/glmQL_decided_txi.rds"))
  Treat_res <- readRDS(file = paste0(Robjectsdir, "/Treat_res_txi.rds"))
  Treat_decided <- readRDS(file = paste0(Robjectsdir, "/Treat_decided_txi.rds"))
}
if (!exists("contrasts_list")){
  contrasts_list <- readRDS(file = paste0(Robjectsdir, "/contrasts.rds"))
}


```


```{r R setting up functions, warning=FALSE}

.hunt <- function(x = "geneID", contrast){
  found <- t2ged[t2ged$target_id %in% "empty",]
  # looping until the entry is found in t2ged
  while(dim(found)[1]==0){
    # separating IDs if a list was given
    if(length(x)==1){
      if(grepl("/",x)|grepl(" ",x)){
        try(x <- strsplit(x, "/"))
        try(x <- strsplit(x, " "))
        x <- unlist(x)
      }
    }
    if (grepl("FBtr",x[[1]],fixed = TRUE)){
      found <- t2ged[t2ged$target_id %in% x,]
    } else if (grepl("FBgn",x[[1]],fixed = TRUE)){
      found <- t2ged[t2ged$ens_gene %in% x,]
    } else if (x[[1]] %in% t2ged$entrez_gene){              
      found <- t2ged[t2ged$entrez_gene %in% x,]
    } else if (x[[1]] %in% t2ged$ext_gene){
      found <- t2ged[t2ged$ext_gene %in% x,]
    } else {
      cat("Please enter either a gene ID in the form of transcript id (FBtrxx), flybase gene ID (Fbgnxxx), gene symbol (e.g. pug), or entrezID (numbers):")
      x<- readline()
    }  
  }
  # getting contrast values for each gene
  temp_table <- glmQL_decided[[contrast]]$table[glmQL_decided[[contrast]]$table$target_id %in% found$target_id,]
  # reordering the table to follow found's order, so values are correctly assigned
  # temp_table<-temp_table[order(factor(temp_table, levels = found$ens_gene)),]
  found <- temp_table[!duplicated(temp_table$ens_gene),]
  return(found)
}

# function saves the Flybase gene IDs in found object for batch search on flyatlas
FBgns_save <- function(){
  label <- paste0(length(found$ens_gene),"_",gsub(":",".",Sys.time()))
  
  write.csv(found$ens_gene, 
            quote = FALSE, 
            file = paste0("C:/Users/Aurelien/Expansion/proj28/plots/tximport plots/batch_searches/",
                          label,".csv"))
  
}
# Call function to assign the contrast of interest.
wcontrast <- function(x = 404){
  x<-as.integer(x)
  num_c <- dim(contrasts_list)[2]
  message <- paste("Please enter a number between 1 to",num_c,"to choose your contrast. Below are the contrast options:\n")
  for (j in 0:3){  # Iterate over the 4 lines
    for (i in seq(1 + j, num_c, by = 4)){  # Print contrasts separated by 4
      message <- paste0(message, i, " - ", names(glmQL_res)[i], "\t")
    } 
    message <- paste0(message, "\n")
  }
  while ( x > num_c| x < 1| is.na(x)){
    cat(message)
    x<- as.integer(readline())
  }
  assigned <<- names(glmQL_res)[x]
  return(assigned)
}
# function to use in other functions to return contrasts without assigning contrast globally
.wcontrast <- function(x = 404){
  x<-as.integer(x)
  num_c <- dim(contrasts_list)[2]
  message <- paste("Please enter a number between 1 to",num_c,"to choose your contrast. Below are the contrast options:\n")
  for (j in 0:3){  # Iterate over the 4 lines
    for (i in seq(1 + j, num_c, by = 4)){  # Print contrasts separated by 4
      message <- paste0(message, i, " - ", colnames(contrasts_list)[i], "\t")
    }
    message <- paste0(message, "\n")
  }
  while ( x > num_c | x < 1 | is.na(x)){
    cat(message)
    x<- as.integer(readline())
  }
  assigned <- colnames(contrasts_list)[x]
  return(assigned)
}
# function to get all transcript IDs associated with entered gene ID (ens,ext,entrez)
.ID_to_trans <- function(x="404"){
  looking <- t2ged[t2ged$target_id %in% "empty",]
  # looping until the entry is found in t2ged
  while(dim(looking)[1]==0){
    # separating IDs if a list was given
    if (grepl("/",x)|grepl(" ",x)){
      try(x <- strsplit(x, "/"))
      try(x <- strsplit(x, " "))
      x <- unlist(x)
    }
    if (grepl("FBgn",x[[1]],fixed = TRUE)){
      looking <- t2ged[t2ged$ens_gene %in% x,]
      
    } else if (x[[1]] %in% t2ged$entrez_gene){              
      looking <- t2ged[t2ged$entrez_gene %in% x,]
      
    } else if (x[[1]] %in% t2ged$ext_gene){
      looking <- t2ged[t2ged$ext_gene %in% x,]
    } else {
      cat("Please enter gene ID in the form of flybase gene ID (Fbgnxxx), gene symbol (e.g. pug), or entrezID (numbers):")
      x<- readline()
    }
  }
  return(looking)
}
# function to retrieve the average logCPM of a list of input transcripts.
gavlogCPM <- function(){
  # retrieving list of transcript IDs with associated gene symbol
  IDs <- .ID_to_trans()
  buffer <- readline("buffer. Just press enter if required.")
  # getting contrast to extract sample groups from
  contrast <- .wcontrast()
  # getting sample groups from contrasts matrix
  sample_groups <- contrasts_list[,contrast]
  sample_groups <- names(sample_groups[sample_groups!=0])
  # getting avlogCPM values for the selected transcripts and sample groups
  # if statement to check if I'm working with transcript-level or gene-level information
  if (dim(glmQL_decided[[1]])[1]==17215){
    avlogCPM_vals <- avlogCPM[IDs$ens_gene,sample_groups]
    # renaming rows to include the gene symbol in them
    rownames(avlogCPM_vals) <- paste0(IDs$ens_gene," (",IDs$ext_gene,")")
  }else{
    avlogCPM_vals <- avlogCPM[IDs$target_id,sample_groups]
    # renaming rows to include the gene symbol in them
    rownames(avlogCPM_vals) <- paste0(IDs$target_id," (",IDs$ext_gene,")")
  }
  # removing NA rows which come from transcript IDs pulled out of t2ged that did not pass the filtering steps. These transcripts don't exist in y so they don't exist in logCPM
  avlogCPM_vals <- avlogCPM_vals[!is.na(avlogCPM_vals[,1]),]
  View(avlogCPM_vals)
  avlogCPM_vals <<- avlogCPM_vals
}

# Function finds given gene entries in t2ged, saves the list globally and opens it to view. you can enter one ID or multiple IDs separated by a "/"
hunt <- function(x = "geneID"){
  looking <- t2ged[t2ged$target_id %in% "empty",]
  # looping until the entry is found in t2ged
  while(dim(looking)[1]==0){
    # separating IDs if a list was given
    if(length(x)==1){
      if(grepl("/",x)|grepl(" ",x)){
        try(x <- strsplit(x, "/"))
        try(x <- strsplit(x, " "))
        x <- unlist(x)
      }
    }
    if (grepl("FBtr",x[[1]],fixed = TRUE)){
      looking <- t2ged[t2ged$target_id %in% x,]
      found <<- t2ged[t2ged$target_id %in% x,]
    } else if (grepl("FBgn",x[[1]],fixed = TRUE)){
      looking <- t2ged[t2ged$ens_gene %in% x,]
      found <<- t2ged[t2ged$ens_gene %in% x,]
    } else if (x[[1]] %in% t2ged$entrez_gene){              
      looking <- t2ged[t2ged$entrez_gene %in% x,]
      found <<- t2ged[t2ged$entrez_gene %in% x,]
    } else if (x[[1]] %in% t2ged$ext_gene){
      looking <- t2ged[t2ged$ext_gene %in% x,]
      found <<- t2ged[t2ged$ext_gene %in% x,]
    } else {
      cat("Please enter either a gene ID in the form of transcript id (FBtrxx), flybase gene ID (Fbgnxxx), gene symbol (e.g. pug), or entrezID (numbers):")
      x<- readline()
    }
  }
  
  # found<<-found[!duplicated(found$ens_gene),]
  # I want to add to the found object a 5th column with information on its expression in the currently assigned contrast, i.e. logFC and FDR for the contrast
  # running which contrast function if not already done
  if (!exists("assigned")){
    .wcontrast()
  }
  # getting contrast values for each gene
  temp_table <<- glmQL_decided[[assigned]]$table[glmQL_decided[[assigned]]$table$target_id %in% found$target_id,]

  
  # reordering the table to follow found's order, so values are correctly assigned
  # temp_table<<-temp_table[order(factor(temp_table, levels = found$ens_gene)),]
  View(temp_table)
  # # adding 5th column with logFC value for assigned contrast
  # found[[paste0("logFC in ",assigned)]] <- temp_table$logFC
  # # adding 6th column with logCPM for assigned contrast
  # found[[paste0("logCPM in ",assigned)]] <- temp_table$logCPM
  # # adding 7th column with FDR for assigned contrast
  # found[[paste0("FDR in ",assigned)]] <- temp_table$FDR
  found <<- temp_table[!duplicated(temp_table$ens_gene),]
  View(found)
  
}

.jhunt <- function(x="404", contrast = NULL){
  # retrieving list of transcript IDs with associated gene symbol
  if(x=="404"){
    IDs <- .ID_to_trans()
  }else{IDs <- .ID_to_trans(x)}
  # buffer <- readline("buffer. Just press enter if required.")
  # getting contrast to extract sample groups from
  contrast <- .wcontrast(contrast)
  # getting sample groups from contrasts matrix
  sample_groups <- contrasts_list[,contrast]
  sample_groups <- names(sample_groups[sample_groups!=0])
  # getting avlogCPM values for the selected transcripts and sample groups
  # if statement to check if I'm working with transcript-level or gene-level information
  if (dim(glmQL_decided[[1]])[1]<20000){
    avlogCPM_vals <- avlogCPM[IDs$ens_gene,sample_groups]
  }else{
    avlogCPM_vals <- avlogCPM[IDs$target_id,sample_groups]
  }
  # removing NA rows which come from transcript IDs pulled out of t2ged that did not pass the filtering steps. These transcripts don't exist in y so they don't exist in logCPM
  avlogCPM_vals <- avlogCPM_vals[!is.na(avlogCPM_vals[,1]),]
  
  DGEvals <-.hunt(IDs$ens_gene, contrast = contrast)
  DGEvals[,6:8] <- list(NULL)
  newtable <- merge(DGEvals, avlogCPM_vals, by=0)
  newtable[,1] <- NULL
  return(newtable)
}

jhunt <- function(x="404"){
  # retrieving list of transcript IDs with associated gene symbol
  if(x=="404"){
    IDs <- .ID_to_trans()
  }else{IDs <- .ID_to_trans(x)}
  buffer <- readline("buffer. Just press enter if required.")
  # getting contrast to extract sample groups from
  contrast <- .wcontrast()
  # getting sample groups from contrasts matrix
  sample_groups <- contrasts_list[,contrast]
  sample_groups <- names(sample_groups[sample_groups!=0])
  # getting avlogCPM values for the selected transcripts and sample groups
  # if statement to check if I'm working with transcript-level or gene-level information
  if (dim(glmQL_decided[[1]])[1]<20000){
    avlogCPM_vals <- avlogCPM[IDs$ens_gene,sample_groups]
  }else{
    avlogCPM_vals <- avlogCPM[IDs$target_id,sample_groups]
  }
  # removing NA rows which come from transcript IDs pulled out of t2ged that did not pass the filtering steps. These transcripts don't exist in y so they don't exist in logCPM
  avlogCPM_vals <- avlogCPM_vals[!is.na(avlogCPM_vals[,1]),]
  DGEvals <-.hunt(IDs$ens_gene, contrast = contrast)
  DGEvals[,6:8] <- list(NULL)
  newtable <- merge(DGEvals, avlogCPM_vals, by=0)
  newtable[,1] <- NULL
  View(newtable)
}
```

### Heatmaps of top 30 DE transcripts in each contrast, mapped onto all contrasts (or cotrasts of same timepoint)

```{r heatmaps top 30 genes for each contrast looped}
names_contrasts <- colnames(contrasts_list)
names_contrasts_48h <- names_contrasts[grepl("48h", names_contrasts, fixed = TRUE)]
names_contrasts_6h <- names_contrasts[grepl("6h", names_contrasts, fixed = TRUE)]

glmQL_res_48h <- glmQL_res[names_contrasts_48h]
glmQL_res_6h <- glmQL_res[names_contrasts_6h]

groupings <- s2c[,2:4]
rownames(groupings)<-s2c$sample
grouping_48h <- grouping[2:3][rownames(grouping)%in% samples_48h,]
grouping_6h <- grouping[2:3][rownames(grouping)%in% samples_6h,]

#looping over every contrast to get top DE transcripts, then make heatmap
for (i in 1:length(names_contrasts)){
  name <- names_contrasts[[i]]
  #ordering results of DE testing function by their pval, smallest to largest
  o <- order(glmQL_res[[name]]$table$PValue)
  loggedcpm = NULL
  #only keeping the logCPM values for the top x DE transcripts
  loggedcpm <- logCPM[o[1:30],]
  print("e")
  # creating heatmap with logCPM values from each sample of the 30 most DE transcripts
  pheatmap(loggedcpm[,colnames(loggedcpm)%in% sample_list], annotation_col = groupings,
           filename = paste0(Heatdir,"/Heatmap top 30 all timepoints - ",name,".pdf"),
           main =name,fontsize_row = 7
           )
}
for (i in 1:length(names_contrasts_48h)){
  name <- names_contrasts_48h[[i]]
  #ordering results of DE testing function by their pval, smallest to largest
  o <- order(glmQL_res_48h[[name]]$table$PValue)
  loggedcpm = NULL
  #only keeping the logCPM values for the top x DE transcripts
  loggedcpm <- logCPM[o[1:30],]
  # creating heatmap with logCPM values from each sample of the 30 most DE transcripts
  pheatmap(loggedcpm[,colnames(loggedcpm)%in% samples_48h], annotation_col = grouping_48h,
           filename = paste0(Heatdir,"/Heatmap top 30 48h - ",name,".pdf"),
           main =name,fontsize_row = 7
           )
}
for (i in 1:length(names_contrasts_6h)){
  name <- names_contrasts_6h[[i]]
  #ordering results of DE testing function by their pval, smallest to largest
  o <- order(glmQL_res_6h[[name]]$table$PValue)
  loggedcpm = NULL
  #only keeping the logCPM values for the top x DE transcripts
  loggedcpm <- logCPM[o[1:30],]
  # creating heatmap with logCPM values from each sample of the 30 most DE transcripts
  pheatmap(loggedcpm[,colnames(loggedcpm)%in% samples_6h], annotation_col = grouping_6h,
           filename = paste0(Heatdir,"/Heatmap top 30 6h - ",name,".pdf"),
           main =name,fontsize_row = 7
           )
}

```

```{r heatmap single contrast}
### Modify the pheatmap inputs if you want to make heatmap over specific group of samples

name <- .wcontrast()
o <- order(glmQL_res[[name]]$table$PValue)
loggedcpm = NULL
#only keeping the logCPM values for the top x DE transcripts
loggedcpm <- logCPM[o[1:30],]
# creating heatmap with logCPM values from each sample of the 30 most DE transcripts
pheatmap(loggedcpm[,colnames(loggedcpm)%in% sample_list], annotation_col = grouping,
         filename = paste0(Heatdir,"/Heatmap top 30 all timepoints - ",name,".pdf"),
         main =name,fontsize_row = 7
         )
```
# Volcano plots 

```{r volcano plot - making and saving plots, eval=FALSE, include=FALSE}
# https://biostatsquid.com/volcano-plots-r-tutorial/

# global settings for ggplot themes
theme_set(theme_classic(base_size = 20) +
            theme(
              axis.title.y = element_text(face = "bold", margin = margin(0,20,0,0), size = rel(1.5), color = 'black'),
              axis.title.x = element_text(hjust = 0.5, face = "bold", margin = margin(20,0,0,0), size = rel(1.5), color = 'black'),
              plot.title = element_text(hjust = 0.5),
              legend.text = element_text(size = rel(0.5))
            ))

for (i in 1:length(glmQL_res)){
  name <- names(glmQL_res)[i]
  # topTags to get BH statistics from differential expression test.
  # graphing the no-cutoff DE result since I'm using volcano plot to visualize significance
  df_nolfc <- topTags(glmQL_res[[name]], n = nrow(glmQL_res[[name]]))
  # adding differentially expressed column to results
  df_nolfc$table$diffexpressed <- "NO"
  # if log2Foldchange > 0.26 and pvalue < 0.05, set as "UP" (lfc(1.2)=0.26)
  df_nolfc$table$diffexpressed[df_nolfc$table$logFC > 0.26 & df_nolfc$table$FDR < 0.05] <- "UP"
  # if log2Foldchange < -0.26 and pvalue < 0.05, set as "DOWN"
  df_nolfc$table$diffexpressed[df_nolfc$table$logFC < -0.26 & df_nolfc$table$FDR < 0.05] <- "DOWN"
  # adding column in table to plot gene symbol for top 30 DE transcripts
  df_nolfc$table$delabel <- c(df_nolfc$table$ext_gene[1:50],
                              rep(NA,length(df_nolfc$table$ext_gene)-50))
  # calling plot
  ggplot(data = df_nolfc, aes(x = logFC, 
                            y = -log10(FDR), 
                            col = diffexpressed,
                            label = delabel)) +
    # adding dashed lines to show significance limits
    geom_vline(xintercept = c(-0.26, 0.26), col = "gray", linetype = 'dashed') +
    geom_hline(yintercept = -log10(0.05), col = "gray", linetype = 'dashed') + 
    geom_point(size =1) + 
    scale_color_manual(values = c("purple2", "grey", "seagreen3"),
                       labels = c("Downregulated", "Not significant", "Upregulated")) + 
    coord_cartesian( xlim = c(-10, 10)) + # since some genes can have minuslog10padj of inf, we set these limits
    labs(color = "Expression",
         x = expression("log"[2]*"FC"), y = expression("-log"[10]*"FDR"),
         title = name) + 
    scale_x_continuous(breaks = seq(-10, 10, 2)) + # to customise the breaks in the x axis
    theme(legend.title = element_text(size = rel(1.5)),
          title = element_text(size = rel(0.5))) +
    geom_text_repel(max.overlaps = Inf) # plotting labels
  ggsave(filename = paste0(Volcanodir, "/volcano_",name, ".pdf"))
}

```

```{r volcano plot single plot}

name <- .wcontrast()
# topTags to get BH statistics from differential expression test.
# graphing the no-cutoff DE result since I'm using volcano plot to visualize significance
df_nolfc <- topTags(glmQL_res[[name]], n = nrow(glmQL_res[[name]]))
# adding differentially expressed column to results
df_nolfc$table$diffexpressed <- "NO"
# if log2Foldchange > 0.26 and pvalue < 0.05, set as "UP" (lfc(1.2)=0.26)
df_nolfc$table$diffexpressed[df_nolfc$table$logFC > 0.26 & df_nolfc$table$FDR < 0.05] <- "UP"
# if log2Foldchange < -0.26 and pvalue < 0.05, set as "DOWN"
df_nolfc$table$diffexpressed[df_nolfc$table$logFC < -0.26 & df_nolfc$table$FDR < 0.05] <- "DOWN"
# adding column in table to plot gene symbol for top 30 DE transcripts
df_nolfc$table$delabel <- c(df_nolfc$table$ext_gene[1:50],
                            rep(NA,length(df_nolfc$table$ext_gene)-50))
# calling plot
ggplot(data = df_nolfc, aes(x = logFC, 
                          y = -log10(FDR), 
                          col = diffexpressed,
                          label = delabel)) +
  # adding dashed lines to show significance limits
  geom_vline(xintercept = c(-0.26, 0.26), col = "gray", linetype = 'dashed') +
  geom_hline(yintercept = -log10(0.05), col = "gray", linetype = 'dashed') + 
  geom_point(size =1) + 
  scale_color_manual(values = c("purple2", "grey", "seagreen3"),
                     labels = c("Downregulated", "Not significant", "Upregulated")) + 
  coord_cartesian( xlim = c(-10, 10)) + # since some genes can have minuslog10padj of inf, we set these limits
  labs(color = "Expression",
       x = expression("log"[2]*"FC"), y = expression("-log"[10]*"FDR"),
       title = name) + 
  scale_x_continuous(breaks = seq(-10, 10, 2)) + # to customise the breaks in the x axis
  theme(legend.title = element_text(size = rel(1.5)),
        title = element_text(size = rel(0.5))) +
  geom_text_repel(max.overlaps = Inf) # plotting labels
ggsave(filename = paste0(Volcanodir, "/volcano_",name, ".pdf"))
```

